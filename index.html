<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Favipong</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #gameCanvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      width: 100vw;
      height: 100vh;
      object-fit: fill;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="16" height="16"></canvas>

  <script>
    // ========== CONFIGURATION ==========
    // WebSocket URL - defaults to production URL
    const WS_URL = (() => {
      if (typeof localStorage !== "undefined" && localStorage.getItem("wsUrl")) {
        return localStorage.getItem("wsUrl");
      }
      return "wss://favipong.onrender.com";
    })();
    const MAX_RECONNECT_ATTEMPTS = 5;
    const RECONNECT_DELAY_BASE = 2000; // ms
    const PADDLE_MOVE_INTERVAL = 50; // ms (slower paddle movement)

    // Canvas settings
    const CANVAS_WIDTH = 16;
    const CANVAS_HEIGHT = 16;
    const CENTER_X = CANVAS_WIDTH / 2;
    const CENTER_Y = CANVAS_HEIGHT / 2;

    // Visual settings
    const BALL_COLOR = "#FFFFFF";
    const BACKGROUND_COLOR = "#000000";
    const TEAM_RED_COLOR = "#FF4444";
    const TEAM_BLUE_COLOR = "#4444FF";
    const WARNING_LINE_COLOR = "rgba(255, 255, 255, ";
    const SCORE_FLASH_GREEN = "#00FF00";
    const SCORE_FLASH_RED = "#FF0000";
    const SCORE_FLASH_DURATION = 30; // frames

    // Paddle settings
    const PADDLE_SIZE = 2;
    const PADDLE_WIDTH = 1; // For vertical paddles
    const PADDLE_HEIGHT = 1; // For horizontal paddles
    const PADDLE_COLLISION_TOLERANCE = 2;

    // Warning line settings
    const WARNING_DISTANCE_MULTIPLIER = 2; // Show warning within 2 favicons
    // ===================================

    // Game state
    let currentNumber = null;
    let totalPlayers = 0;
    let currentTeam = null;
    let ws = null;
    let reconnectAttempts = 0;

  // Game state from server
  let gameState = {
    ballX: CENTER_X,
    ballY: CENTER_Y,
    ballVelX: 0.15,
    paddlePositions: {},
    teamScores: { red: 0, blue: 0 },
    lastScoringTeam: null,
  };

    // Score flash state
    let scoreFlashFrames = 0;
    let flashColor = null; // 'green' or 'red'
    let previousBallX = null;
    let previousBallY = null;
    let previousBallVelX = null;
    let previousBallVelY = null;
    let ballWasInMyArea = false;

    // Paddle movement keys
    const keys = {};

    // Canvas elements
    const faviconCanvas = document.createElement("canvas");
    faviconCanvas.width = CANVAS_WIDTH;
    faviconCanvas.height = CANVAS_HEIGHT;
    const faviconCtx = faviconCanvas.getContext("2d");

    const gameCanvas = document.getElementById("gameCanvas");
    const gameCtx = gameCanvas.getContext("2d");

    // Get team color for a player number
    function getTeamColor(playerNum) {
      return playerNum % 2 === 1 ? TEAM_RED_COLOR : TEAM_BLUE_COLOR;
    }

    // Update document title with scores
    function updateTitle() {
      if (!gameState.teamScores) return;
      const redScore = gameState.teamScores.red || 0;
      const blueScore = gameState.teamScores.blue || 0;
      document.title = `${redScore}:${blueScore}`;
    }

    // Check if ball is in player's area
    function isBallInMyArea() {
      if (!currentNumber || !totalPlayers) return false;
      const faviconStartX = (currentNumber - 1) * CANVAS_WIDTH;
      const faviconEndX = currentNumber * CANVAS_WIDTH;
      return gameState.ballX >= faviconStartX && gameState.ballX < faviconEndX;
    }

    // Check if ball is near player's paddle edge
    function isBallNearPaddleEdge() {
      if (!currentNumber || !totalPlayers) return false;
      
      const faviconStartX = (currentNumber - 1) * CANVAS_WIDTH;
      const faviconEndX = currentNumber * CANVAS_WIDTH;
      const paddleY = gameState.paddlePositions[currentNumber] || CENTER_Y;
      
      // Player 1: left edge paddle
      if (currentNumber === 1) {
        const ballAtLeftEdge = gameState.ballX <= PADDLE_SIZE + 1;
        const ballNearPaddleY = Math.abs(gameState.ballY - paddleY) <= PADDLE_SIZE + PADDLE_COLLISION_TOLERANCE;
        return ballAtLeftEdge && ballNearPaddleY;
      }
      // Last player: right edge paddle
      else if (currentNumber === totalPlayers) {
        const ballAtRightEdge = gameState.ballX >= faviconEndX - PADDLE_SIZE - 1;
        const ballNearPaddleY = Math.abs(gameState.ballY - paddleY) <= PADDLE_SIZE + PADDLE_COLLISION_TOLERANCE;
        return ballAtRightEdge && ballNearPaddleY;
      }
      // Middle players: top/bottom paddles
      else {
        const paddleX = (currentNumber - 1) * CANVAS_WIDTH + paddleY;
        const ballAtTop = gameState.ballY <= PADDLE_SIZE + 1;
        const ballAtBottom = gameState.ballY >= CANVAS_HEIGHT - PADDLE_SIZE - 1;
        const ballNearPaddleX = Math.abs(gameState.ballX - paddleX) <= PADDLE_SIZE + PADDLE_COLLISION_TOLERANCE;
        return (ballAtTop || ballAtBottom) && ballNearPaddleX;
      }
    }

    // Check for hit/miss and trigger flash
    function checkHitOrMiss() {
      if (!currentNumber || !totalPlayers) {
        ballWasInMyArea = false;
        previousBallX = gameState.ballX;
        previousBallY = gameState.ballY;
        previousBallVelX = gameState.ballVelX;
        previousBallVelY = gameState.ballVelY;
        return;
      }

      const ballInMyArea = isBallInMyArea();
      const faviconStartX = (currentNumber - 1) * CANVAS_WIDTH;
      const faviconEndX = currentNumber * CANVAS_WIDTH;
      const worldWidth = CANVAS_WIDTH * totalPlayers;

      // Ball just entered my area
      if (ballInMyArea && !ballWasInMyArea) {
        ballWasInMyArea = true;
      }

      // Check for velocity change (indicates a collision)
      const velocityChangedX = previousBallVelX !== null && 
        ((previousBallVelX > 0 && gameState.ballVelX < 0) || 
         (previousBallVelX < 0 && gameState.ballVelX > 0));
      const velocityChangedY = previousBallVelY !== null && 
        ((previousBallVelY > 0 && gameState.ballVelY < 0) || 
         (previousBallVelY < 0 && gameState.ballVelY > 0));
      
      const isEdgePlayer = currentNumber === 1 || currentNumber === totalPlayers;
      
      // For edge players (left/right paddles)
      if (isEdgePlayer && velocityChangedX) {
        // Check if ball hit the wall or the paddle
        const hitLeftWall = currentNumber === 1 && gameState.ballX <= 0.5;
        const hitRightWall = currentNumber === totalPlayers && gameState.ballX >= worldWidth - 0.5;
        const ballNearPaddle = isBallNearPaddleEdge();
        
        if (hitLeftWall || hitRightWall) {
          // Ball hit the wall - red flash (missed paddle)
          scoreFlashFrames = SCORE_FLASH_DURATION;
          flashColor = 'red';
        } else if (ballNearPaddle) {
          // Ball hit the paddle - green flash (hit paddle)
          scoreFlashFrames = SCORE_FLASH_DURATION;
          flashColor = 'green';
        }
      }
      // For middle players (top/bottom paddles)
      else if (!isEdgePlayer && velocityChangedY) {
        const ballNearPaddle = isBallNearPaddleEdge();
        if (ballNearPaddle) {
          // Ball hit the paddle - green flash
          scoreFlashFrames = SCORE_FLASH_DURATION;
          flashColor = 'green';
        }
      }

      previousBallX = gameState.ballX;
      previousBallY = gameState.ballY;
      previousBallVelX = gameState.ballVelX;
      previousBallVelY = gameState.ballVelY;

      if (scoreFlashFrames > 0) {
        scoreFlashFrames--;
      } else {
        flashColor = null;
      }
    }

    // Render game to canvas
    function renderGame(canvas, ctx) {
      if (!currentNumber || !totalPlayers) {
        ctx.fillStyle = BACKGROUND_COLOR;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        return;
      }

      // Enable pixelated rendering
      ctx.imageSmoothingEnabled = false;

      // Check for hit/miss
      checkHitOrMiss();

      // Draw background with flash effect
      if (scoreFlashFrames > 0 && flashColor) {
        const flashColorHex = flashColor === 'green' ? SCORE_FLASH_GREEN : SCORE_FLASH_RED;
        const flashIntensity = scoreFlashFrames / SCORE_FLASH_DURATION;
        ctx.fillStyle = flashColorHex;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = BACKGROUND_COLOR;
        ctx.globalAlpha = 1 - flashIntensity * 0.5;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
      } else {
        ctx.fillStyle = BACKGROUND_COLOR;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      // Calculate this favicon's slice of the world
      const faviconStartX = (currentNumber - 1) * CANVAS_WIDTH;
      const faviconEndX = currentNumber * CANVAS_WIDTH;
      const worldWidth = CANVAS_WIDTH * totalPlayers;
      const maxWarningDistance = CANVAS_WIDTH * WARNING_DISTANCE_MULTIPLIER;
      const ballInMyArea = gameState.ballX >= faviconStartX && gameState.ballX < faviconEndX;

      // Left warning line (ball coming from left)
      // For player 1, show warning when ball is approaching from right (within their area)
      // For other players, show warning when ball is approaching from left (outside their area)
      const leftEdgeX = faviconStartX;
      const distanceFromLeftEdge = gameState.ballX - leftEdgeX;
      const showLeftWarning = currentNumber === 1 
        ? (ballInMyArea && gameState.ballVelX < 0 && distanceFromLeftEdge <= maxWarningDistance)
        : (distanceFromLeftEdge >= -maxWarningDistance && distanceFromLeftEdge <= maxWarningDistance && gameState.ballVelX > 0);
      
      if (showLeftWarning) {
        const distance = Math.abs(distanceFromLeftEdge);
        const intensity = Math.max(0, 1 - distance / maxWarningDistance);
        const lineHeight = Math.floor(CANVAS_HEIGHT * intensity);
        const opacity = intensity;

        if (lineHeight > 0) {
          ctx.fillStyle = `${WARNING_LINE_COLOR}${opacity})`;
          ctx.fillRect(0, (CANVAS_HEIGHT - lineHeight) / 2, 1, lineHeight);
        }
      }

      // Right warning line (ball coming from right)
      // For last player, show warning when ball is approaching from left (within their area)
      // For other players, show warning when ball is approaching from right (outside their area)
      const rightEdgeX = faviconEndX;
      const distanceFromRightEdge = rightEdgeX - gameState.ballX;
      const showRightWarning = currentNumber === totalPlayers
        ? (ballInMyArea && gameState.ballVelX > 0 && distanceFromRightEdge <= maxWarningDistance)
        : (distanceFromRightEdge >= -maxWarningDistance && distanceFromRightEdge <= maxWarningDistance && gameState.ballVelX < 0);
      
      if (showRightWarning) {
        const distance = Math.abs(distanceFromRightEdge);
        const intensity = Math.max(0, 1 - distance / maxWarningDistance);
        const lineHeight = Math.floor(CANVAS_HEIGHT * intensity);
        const opacity = intensity;

        if (lineHeight > 0) {
          ctx.fillStyle = `${WARNING_LINE_COLOR}${opacity})`;
          ctx.fillRect(CANVAS_WIDTH - 1, (CANVAS_HEIGHT - lineHeight) / 2, 1, lineHeight);
        }
      }

      // Draw ball only if it's in this favicon's slice
      if (gameState.ballX >= faviconStartX && gameState.ballX < faviconEndX) {
        const localBallX = gameState.ballX - faviconStartX;
        ctx.fillStyle = BALL_COLOR;
        ctx.fillRect(Math.floor(localBallX), Math.floor(gameState.ballY), 1, 1);
      }

      // Draw paddles based on player number with team colors
      if (currentNumber === 1) {
        // Player 1: Left paddle (vertical) at left edge
        const paddleY = gameState.paddlePositions[1] || CENTER_Y;
        ctx.fillStyle = getTeamColor(1);
        ctx.fillRect(0, paddleY - PADDLE_SIZE, PADDLE_WIDTH, PADDLE_SIZE * 2);
      } else if (currentNumber === totalPlayers && totalPlayers > 1) {
        // Last player: Right paddle (vertical) at right edge
        const paddleY = gameState.paddlePositions[totalPlayers] || CENTER_Y;
        ctx.fillStyle = getTeamColor(totalPlayers);
        ctx.fillRect(CANVAS_WIDTH - 1, paddleY - PADDLE_SIZE, PADDLE_WIDTH, PADDLE_SIZE * 2);
      } else if (currentNumber > 1 && currentNumber < totalPlayers) {
        // Middle players: Top and bottom paddles (horizontal)
        const paddleX = gameState.paddlePositions[currentNumber] || CENTER_Y;
        const teamColor = getTeamColor(currentNumber);

        // Top paddle
        ctx.fillStyle = teamColor;
        ctx.fillRect(paddleX - PADDLE_SIZE, 0, PADDLE_SIZE * 2, PADDLE_HEIGHT);

        // Bottom paddle
        ctx.fillStyle = teamColor;
        ctx.fillRect(paddleX - PADDLE_SIZE, CANVAS_HEIGHT - 1, PADDLE_SIZE * 2, PADDLE_HEIGHT);
      }
    }

    function updateFavicon() {
      renderGame(faviconCanvas, faviconCtx);
      const dataUrl = faviconCanvas.toDataURL("image/png");

      let faviconLink = document.querySelector("link[rel*='icon']");
      if (!faviconLink) {
        faviconLink = document.createElement("link");
        faviconLink.rel = "icon";
        document.head.appendChild(faviconLink);
      }
      faviconLink.href = dataUrl;

      let appleIcon = document.querySelector("link[rel='apple-touch-icon']");
      if (appleIcon) {
        appleIcon.href = dataUrl;
      }
    }

    function updateGameDisplay() {
      renderGame(gameCanvas, gameCtx);
      updateFavicon();
      updateTitle();
    }

    function connectWebSocket() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        return;
      }

      try {
        console.log("Connecting to WebSocket server...");
        ws = new WebSocket(WS_URL);

        ws.onopen = () => {
          console.log("Connected to WebSocket server");
          reconnectAttempts = 0;
        };

        ws.onmessage = (event) => {
          try {
            const message = JSON.parse(event.data);

            if (message.type === "assigned") {
              currentNumber = message.number;
              totalPlayers = message.totalPlayers || 0;
              currentTeam = message.team || null;
              console.log("Assigned number:", currentNumber, "Team:", currentTeam, "Total players:", totalPlayers);
              setupControls();
              updateGameDisplay();
            } else if (message.type === "gameState") {
              gameState.ballX = message.ballX || CENTER_X;
              gameState.ballY = message.ballY || CENTER_Y;
              gameState.ballVelX = message.ballVelX || 0.15;
              gameState.paddlePositions = message.paddlePositions || {};
              gameState.teamScores = message.teamScores || { red: 0, blue: 0 };
              gameState.lastScoringTeam = message.lastScoringTeam || null;
              totalPlayers = message.totalPlayers || totalPlayers;
              updateGameDisplay();
            }
          } catch (error) {
            console.error("Error parsing WebSocket message:", error);
          }
        };

        ws.onerror = (error) => {
          console.error("WebSocket error:", error);
        };

        ws.onclose = () => {
          console.log("WebSocket connection closed");
          ws = null;
          currentNumber = null;

          if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
            reconnectAttempts++;
            setTimeout(() => {
              console.log(`Reconnecting... (attempt ${reconnectAttempts})`);
              connectWebSocket();
            }, RECONNECT_DELAY_BASE * reconnectAttempts);
          }
        };
      } catch (error) {
        console.error("Error creating WebSocket connection:", error);
        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          reconnectAttempts++;
          setTimeout(() => {
            console.log(`Retrying connection... (attempt ${reconnectAttempts})`);
            connectWebSocket();
          }, RECONNECT_DELAY_BASE * reconnectAttempts);
        }
      }
    }

    let paddleMoveInterval = null;

    function setupControls() {
      if (!currentNumber || !ws) return;

      document.removeEventListener("keydown", handlePaddleKeyDown);
      document.removeEventListener("keyup", handlePaddleKeyUp);

      document.addEventListener("keydown", handlePaddleKeyDown);
      document.addEventListener("keyup", handlePaddleKeyUp);
    }

    function handlePaddleKeyDown(e) {
      if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
        return;
      }

      // Player 1 or last player: Up/Down for vertical paddles
      if ((currentNumber === 1 || currentNumber === totalPlayers) && totalPlayers > 1) {
        if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") {
          e.preventDefault();
          if (!keys.up) {
            keys.up = true;
            sendPaddleMove("up");
            startContinuousMove("up");
          }
        } else if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") {
          e.preventDefault();
          if (!keys.down) {
            keys.down = true;
            sendPaddleMove("down");
            startContinuousMove("down");
          }
        }
      }
      // Middle players: Left/Right for horizontal paddles
      else if (currentNumber > 1 && currentNumber < totalPlayers) {
        if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") {
          e.preventDefault();
          if (!keys.left) {
            keys.left = true;
            sendPaddleMove("left");
            startContinuousMove("left");
          }
        } else if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") {
          e.preventDefault();
          if (!keys.right) {
            keys.right = true;
            sendPaddleMove("right");
            startContinuousMove("right");
          }
        }
      }
    }

    function startContinuousMove(direction) {
      if (paddleMoveInterval) {
        clearInterval(paddleMoveInterval);
      }
      paddleMoveInterval = setInterval(() => {
        if (
          (direction === "up" && keys.up) ||
          (direction === "down" && keys.down) ||
          (direction === "left" && keys.left) ||
          (direction === "right" && keys.right)
        ) {
          sendPaddleMove(direction);
        } else {
          clearInterval(paddleMoveInterval);
          paddleMoveInterval = null;
        }
      }, PADDLE_MOVE_INTERVAL);
    }

    function handlePaddleKeyUp(e) {
      if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") {
        keys.up = false;
        if (paddleMoveInterval && !keys.down && !keys.left && !keys.right) {
          clearInterval(paddleMoveInterval);
          paddleMoveInterval = null;
        }
      } else if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") {
        keys.down = false;
        if (paddleMoveInterval && !keys.up && !keys.left && !keys.right) {
          clearInterval(paddleMoveInterval);
          paddleMoveInterval = null;
        }
      } else if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") {
        keys.left = false;
        if (paddleMoveInterval && !keys.up && !keys.down && !keys.right) {
          clearInterval(paddleMoveInterval);
          paddleMoveInterval = null;
        }
      } else if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") {
        keys.right = false;
        if (paddleMoveInterval && !keys.up && !keys.down && !keys.left) {
          clearInterval(paddleMoveInterval);
          paddleMoveInterval = null;
        }
      }
    }

    function sendPaddleMove(direction) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(
          JSON.stringify({
            type: "paddleMove",
            direction: direction,
          })
        );
      }
    }

    // Connect when page loads
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", connectWebSocket);
    } else {
      connectWebSocket();
    }

    // Reconnect on page visibility change
    document.addEventListener("visibilitychange", () => {
      if (!document.hidden && (!ws || ws.readyState !== WebSocket.OPEN)) {
        connectWebSocket();
      } else if (currentNumber && !document.hidden) {
        updateGameDisplay();
      }
    });
  </script>
</body>
</html>
