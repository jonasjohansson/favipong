<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Favipong - WebSocket Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #000;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      text-align: center;
      max-width: 1200px;
      width: 100%;
    }

    h1 {
      margin-bottom: 20px;
      font-size: 2.5em;
    }

    .status {
      margin-bottom: 20px;
      font-size: 1.2em;
      opacity: 0.8;
    }

    .game-canvas-container {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 20px 0;
      background: #111;
      border: 2px solid #333;
      border-radius: 8px;
      padding: 20px;
    }

    #gameCanvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      max-width: 100%;
      height: auto;
    }

    .controls {
      margin-top: 20px;
      font-size: 0.9em;
      opacity: 0.7;
    }

    .team-info {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin-top: 20px;
      font-size: 1.1em;
    }

    .team {
      padding: 10px 20px;
      border-radius: 4px;
    }

    .team-red {
      color: #ff4444;
    }

    .team-blue {
      color: #4444ff;
    }

    .connection-status {
      margin-top: 20px;
      padding: 10px;
      border-radius: 4px;
      font-size: 0.9em;
    }

    .connected {
      background: rgba(0, 255, 0, 0.2);
      color: #0f0;
    }

    .disconnected {
      background: rgba(255, 0, 0, 0.2);
      color: #f00;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸŽ® Favipong</h1>
    <div id="status" class="status">Connecting...</div>
    
    <div class="game-canvas-container">
      <canvas id="gameCanvas" width="16" height="16"></canvas>
    </div>

    <div class="team-info">
      <div class="team team-red">
        <strong>Red Team:</strong> <span id="redScore">0</span>
      </div>
      <div class="team team-blue">
        <strong>Blue Team:</strong> <span id="blueScore">0</span>
      </div>
    </div>

    <div id="connectionStatus" class="connection-status disconnected">
      Disconnected
    </div>

    <div class="controls">
      <p>Use arrow keys or WASD to control your paddle</p>
      <p id="playerInfo">Waiting for assignment...</p>
    </div>
  </div>

  <script>
    // ========== CONFIGURATION ==========
    // WebSocket URL - defaults to production URL
    const WS_URL = (() => {
      // Check localStorage first (for runtime configuration/override)
      if (typeof localStorage !== "undefined" && localStorage.getItem("wsUrl")) {
        return localStorage.getItem("wsUrl");
      }
      // Default to production Render.com URL
      return "wss://favipong.onrender.com";
    })();
    const MAX_RECONNECT_ATTEMPTS = 5;
    const RECONNECT_DELAY_BASE = 2000; // ms
    const PADDLE_MOVE_INTERVAL = 16; // ms (~60 FPS)

    // Canvas settings
    const CANVAS_WIDTH = 16;
    const CANVAS_HEIGHT = 16;
    const CENTER_X = CANVAS_WIDTH / 2;
    const CENTER_Y = CANVAS_HEIGHT / 2;

    // Visual settings
    const BALL_COLOR = "#FFFFFF";
    const BACKGROUND_COLOR = "#000000";
    const TEAM_RED_COLOR = "#FF4444";
    const TEAM_BLUE_COLOR = "#4444FF";
    const WARNING_LINE_COLOR = "rgba(255, 255, 255, ";
    const SCORE_FLASH_GREEN = "#00FF00";
    const SCORE_FLASH_RED = "#FF0000";
    const SCORE_FLASH_DURATION = 30; // frames

    // Paddle settings
    const PADDLE_SIZE = 2;
    const PADDLE_WIDTH = 1; // For vertical paddles
    const PADDLE_HEIGHT = 1; // For horizontal paddles

    // Warning line settings
    const WARNING_DISTANCE_MULTIPLIER = 2; // Show warning within 2 favicons
    // ===================================

    // Game state
    let currentNumber = null;
    let totalPlayers = 0;
    let currentTeam = null;
    let ws = null;
    let reconnectAttempts = 0;

    // Game state from server
    let gameState = {
      ballX: CENTER_X,
      ballY: CENTER_Y,
      ballVelX: 0.25,
      paddlePositions: {},
      teamScores: { red: 0, blue: 0 },
      lastScoringTeam: null,
    };

    // Score flash state
    let scoreFlashFrames = 0;
    let previousRedScore = 0;
    let previousBlueScore = 0;

    // Paddle movement keys
    const keys = {};

    // Canvas elements
    const faviconCanvas = document.createElement("canvas");
    faviconCanvas.width = CANVAS_WIDTH;
    faviconCanvas.height = CANVAS_HEIGHT;
    const faviconCtx = faviconCanvas.getContext("2d");

    const gameCanvas = document.getElementById("gameCanvas");
    const gameCtx = gameCanvas.getContext("2d");

    // Scale canvas to fill available space while maintaining aspect ratio
    function resizeCanvas() {
      const container = gameCanvas.parentElement;
      const maxWidth = container.clientWidth - 40; // padding
      const maxHeight = window.innerHeight * 0.6;
      
      const scale = Math.min(
        Math.floor(maxWidth / CANVAS_WIDTH),
        Math.floor(maxHeight / CANVAS_HEIGHT)
      );
      
      // Ensure minimum scale of 20x
      const finalScale = Math.max(20, scale);
      
      gameCanvas.style.width = `${CANVAS_WIDTH * finalScale}px`;
      gameCanvas.style.height = `${CANVAS_HEIGHT * finalScale}px`;
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Get team color for a player number
    function getTeamColor(playerNum) {
      return playerNum % 2 === 1 ? TEAM_RED_COLOR : TEAM_BLUE_COLOR;
    }

    // Update UI elements
    function updateUI() {
      const statusEl = document.getElementById("status");
      const playerInfoEl = document.getElementById("playerInfo");
      const redScoreEl = document.getElementById("redScore");
      const blueScoreEl = document.getElementById("blueScore");
      const connectionStatusEl = document.getElementById("connectionStatus");

      if (currentNumber) {
        statusEl.textContent = `Player ${currentNumber} of ${totalPlayers} | Team: ${currentTeam ? currentTeam.toUpperCase() : 'N/A'}`;
        playerInfoEl.textContent = `You are Player ${currentNumber} (${currentTeam ? currentTeam.toUpperCase() : 'N/A'} Team)`;
      } else {
        statusEl.textContent = "Connecting...";
        playerInfoEl.textContent = "Waiting for assignment...";
      }

      redScoreEl.textContent = gameState.teamScores.red || 0;
      blueScoreEl.textContent = gameState.teamScores.blue || 0;

      if (ws && ws.readyState === WebSocket.OPEN) {
        connectionStatusEl.textContent = "Connected";
        connectionStatusEl.className = "connection-status connected";
      } else {
        connectionStatusEl.textContent = "Disconnected";
        connectionStatusEl.className = "connection-status disconnected";
      }
    }

    // Update document title with scores and player count
    function updateTitle() {
      if (!gameState.teamScores) return;
      const redScore = gameState.teamScores.red || 0;
      const blueScore = gameState.teamScores.blue || 0;
      document.title = `Favipong - ${redScore}:${blueScore} (${totalPlayers} players)`;
    }

    // Check for score changes and trigger flash
    function checkScoreChange() {
      const redScore = gameState.teamScores.red || 0;
      const blueScore = gameState.teamScores.blue || 0;

      if (redScore !== previousRedScore || blueScore !== previousBlueScore) {
        if (gameState.lastScoringTeam === currentTeam) {
          scoreFlashFrames = SCORE_FLASH_DURATION;
        } else if (gameState.lastScoringTeam) {
          scoreFlashFrames = SCORE_FLASH_DURATION;
        }
        previousRedScore = redScore;
        previousBlueScore = blueScore;
      }

      if (scoreFlashFrames > 0) {
        scoreFlashFrames--;
      }
    }

    // Render game to canvas
    function renderGame(canvas, ctx) {
      if (!currentNumber || !totalPlayers) {
        ctx.fillStyle = BACKGROUND_COLOR;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        return;
      }

      // Enable better rendering quality
      ctx.imageSmoothingEnabled = false; // Pixelated look

      // Check for score changes
      checkScoreChange();

      // Draw background with score flash effect
      if (scoreFlashFrames > 0 && gameState.lastScoringTeam) {
        const isOurTeam = gameState.lastScoringTeam === currentTeam;
        const flashColor = isOurTeam ? SCORE_FLASH_GREEN : SCORE_FLASH_RED;
        const flashIntensity = scoreFlashFrames / SCORE_FLASH_DURATION;
        ctx.fillStyle = flashColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = BACKGROUND_COLOR;
        ctx.globalAlpha = 1 - flashIntensity * 0.5;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
      } else {
        ctx.fillStyle = BACKGROUND_COLOR;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      // Calculate this favicon's slice of the world
      const faviconStartX = (currentNumber - 1) * CANVAS_WIDTH;
      const faviconEndX = currentNumber * CANVAS_WIDTH;
      const worldWidth = CANVAS_WIDTH * totalPlayers;
      const maxWarningDistance = CANVAS_WIDTH * WARNING_DISTANCE_MULTIPLIER;

      // Left warning line (ball coming from left)
      const leftEdgeX = faviconStartX;
      const distanceFromLeftEdge = gameState.ballX - leftEdgeX;
      if (distanceFromLeftEdge >= -maxWarningDistance && distanceFromLeftEdge <= maxWarningDistance && gameState.ballVelX > 0) {
        const distance = Math.abs(distanceFromLeftEdge);
        const intensity = Math.max(0, 1 - distance / maxWarningDistance);
        const lineHeight = Math.floor(CANVAS_HEIGHT * intensity);
        const opacity = intensity;

        if (lineHeight > 0) {
          ctx.fillStyle = `${WARNING_LINE_COLOR}${opacity})`;
          ctx.fillRect(0, (CANVAS_HEIGHT - lineHeight) / 2, 1, lineHeight);
        }
      }

      // Right warning line (ball coming from right)
      const rightEdgeX = faviconEndX;
      const distanceFromRightEdge = rightEdgeX - gameState.ballX;
      if (distanceFromRightEdge >= -maxWarningDistance && distanceFromRightEdge <= maxWarningDistance && gameState.ballVelX < 0) {
        const distance = Math.abs(distanceFromRightEdge);
        const intensity = Math.max(0, 1 - distance / maxWarningDistance);
        const lineHeight = Math.floor(CANVAS_HEIGHT * intensity);
        const opacity = intensity;

        if (lineHeight > 0) {
          ctx.fillStyle = `${WARNING_LINE_COLOR}${opacity})`;
          ctx.fillRect(CANVAS_WIDTH - 1, (CANVAS_HEIGHT - lineHeight) / 2, 1, lineHeight);
        }
      }

      // Draw ball only if it's in this favicon's slice
      if (gameState.ballX >= faviconStartX && gameState.ballX < faviconEndX) {
        const localBallX = gameState.ballX - faviconStartX;
        ctx.fillStyle = BALL_COLOR;
        ctx.fillRect(Math.floor(localBallX), Math.floor(gameState.ballY), 1, 1);
      }

      // Draw paddles based on player number with team colors
      if (currentNumber === 1) {
        // Player 1: Left paddle (vertical) at left edge
        const paddleY = gameState.paddlePositions[1] || CENTER_Y;
        ctx.fillStyle = getTeamColor(1);
        ctx.fillRect(0, paddleY - PADDLE_SIZE, PADDLE_WIDTH, PADDLE_SIZE * 2);
      } else if (currentNumber === totalPlayers && totalPlayers > 1) {
        // Last player: Right paddle (vertical) at right edge
        const paddleY = gameState.paddlePositions[totalPlayers] || CENTER_Y;
        ctx.fillStyle = getTeamColor(totalPlayers);
        ctx.fillRect(CANVAS_WIDTH - 1, paddleY - PADDLE_SIZE, PADDLE_WIDTH, PADDLE_SIZE * 2);
      } else if (currentNumber > 1 && currentNumber < totalPlayers) {
        // Middle players: Top and bottom paddles (horizontal)
        const paddleX = gameState.paddlePositions[currentNumber] || CENTER_Y;
        const teamColor = getTeamColor(currentNumber);

        // Top paddle
        ctx.fillStyle = teamColor;
        ctx.fillRect(paddleX - PADDLE_SIZE, 0, PADDLE_SIZE * 2, PADDLE_HEIGHT);

        // Bottom paddle
        ctx.fillStyle = teamColor;
        ctx.fillRect(paddleX - PADDLE_SIZE, CANVAS_HEIGHT - 1, PADDLE_SIZE * 2, PADDLE_HEIGHT);
      }
    }

    function updateFavicon() {
      renderGame(faviconCanvas, faviconCtx);
      const dataUrl = faviconCanvas.toDataURL("image/png");

      let faviconLink = document.querySelector("link[rel*='icon']");
      if (!faviconLink) {
        faviconLink = document.createElement("link");
        faviconLink.rel = "icon";
        document.head.appendChild(faviconLink);
      }
      faviconLink.href = dataUrl;

      let appleIcon = document.querySelector("link[rel='apple-touch-icon']");
      if (appleIcon) {
        appleIcon.href = dataUrl;
      }
    }

    function updateGameDisplay() {
      renderGame(gameCanvas, gameCtx);
      updateFavicon();
      updateUI();
      updateTitle();
    }

    function connectWebSocket() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        return;
      }

      try {
        console.log("Connecting to WebSocket server...");
        ws = new WebSocket(WS_URL);

        ws.onopen = () => {
          console.log("Connected to WebSocket server");
          reconnectAttempts = 0;
          updateUI();
        };

        ws.onmessage = (event) => {
          try {
            const message = JSON.parse(event.data);

            if (message.type === "assigned") {
              currentNumber = message.number;
              totalPlayers = message.totalPlayers || 0;
              currentTeam = message.team || null;
              console.log("Assigned number:", currentNumber, "Team:", currentTeam, "Total players:", totalPlayers);
              setupControls();
              updateGameDisplay();
            } else if (message.type === "gameState") {
              gameState.ballX = message.ballX || CENTER_X;
              gameState.ballY = message.ballY || CENTER_Y;
              gameState.ballVelX = message.ballVelX || 0.25;
              gameState.paddlePositions = message.paddlePositions || {};
              gameState.teamScores = message.teamScores || { red: 0, blue: 0 };
              gameState.lastScoringTeam = message.lastScoringTeam || null;
              totalPlayers = message.totalPlayers || totalPlayers;
              updateGameDisplay();
            }
          } catch (error) {
            console.error("Error parsing WebSocket message:", error);
          }
        };

        ws.onerror = (error) => {
          console.error("WebSocket error:", error);
          updateUI();
        };

        ws.onclose = () => {
          console.log("WebSocket connection closed");
          ws = null;
          currentNumber = null;
          updateUI();

          if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
            reconnectAttempts++;
            setTimeout(() => {
              console.log(`Reconnecting... (attempt ${reconnectAttempts})`);
              connectWebSocket();
            }, RECONNECT_DELAY_BASE * reconnectAttempts);
          }
        };
      } catch (error) {
        console.error("Error creating WebSocket connection:", error);
        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          reconnectAttempts++;
          setTimeout(() => {
            console.log(`Retrying connection... (attempt ${reconnectAttempts})`);
            connectWebSocket();
          }, RECONNECT_DELAY_BASE * reconnectAttempts);
        }
      }
    }

    let paddleMoveInterval = null;

    function setupControls() {
      if (!currentNumber || !ws) return;

      document.removeEventListener("keydown", handlePaddleKeyDown);
      document.removeEventListener("keyup", handlePaddleKeyUp);

      document.addEventListener("keydown", handlePaddleKeyDown);
      document.addEventListener("keyup", handlePaddleKeyUp);
    }

    function handlePaddleKeyDown(e) {
      if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
        return;
      }

      // Player 1 or last player: Up/Down for vertical paddles
      if ((currentNumber === 1 || currentNumber === totalPlayers) && totalPlayers > 1) {
        if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") {
          e.preventDefault();
          if (!keys.up) {
            keys.up = true;
            sendPaddleMove("up");
            startContinuousMove("up");
          }
        } else if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") {
          e.preventDefault();
          if (!keys.down) {
            keys.down = true;
            sendPaddleMove("down");
            startContinuousMove("down");
          }
        }
      }
      // Middle players: Left/Right for horizontal paddles
      else if (currentNumber > 1 && currentNumber < totalPlayers) {
        if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") {
          e.preventDefault();
          if (!keys.left) {
            keys.left = true;
            sendPaddleMove("left");
            startContinuousMove("left");
          }
        } else if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") {
          e.preventDefault();
          if (!keys.right) {
            keys.right = true;
            sendPaddleMove("right");
            startContinuousMove("right");
          }
        }
      }
    }

    function startContinuousMove(direction) {
      if (paddleMoveInterval) {
        clearInterval(paddleMoveInterval);
      }
      paddleMoveInterval = setInterval(() => {
        if (
          (direction === "up" && keys.up) ||
          (direction === "down" && keys.down) ||
          (direction === "left" && keys.left) ||
          (direction === "right" && keys.right)
        ) {
          sendPaddleMove(direction);
        } else {
          clearInterval(paddleMoveInterval);
          paddleMoveInterval = null;
        }
      }, PADDLE_MOVE_INTERVAL);
    }

    function handlePaddleKeyUp(e) {
      if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") {
        keys.up = false;
        if (paddleMoveInterval && !keys.down && !keys.left && !keys.right) {
          clearInterval(paddleMoveInterval);
          paddleMoveInterval = null;
        }
      } else if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") {
        keys.down = false;
        if (paddleMoveInterval && !keys.up && !keys.left && !keys.right) {
          clearInterval(paddleMoveInterval);
          paddleMoveInterval = null;
        }
      } else if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") {
        keys.left = false;
        if (paddleMoveInterval && !keys.up && !keys.down && !keys.right) {
          clearInterval(paddleMoveInterval);
          paddleMoveInterval = null;
        }
      } else if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") {
        keys.right = false;
        if (paddleMoveInterval && !keys.up && !keys.down && !keys.left) {
          clearInterval(paddleMoveInterval);
          paddleMoveInterval = null;
        }
      }
    }

    function sendPaddleMove(direction) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(
          JSON.stringify({
            type: "paddleMove",
            direction: direction,
          })
        );
      }
    }

    // Connect when page loads
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", connectWebSocket);
    } else {
      connectWebSocket();
    }

    // Reconnect on page visibility change
    document.addEventListener("visibilitychange", () => {
      if (!document.hidden && (!ws || ws.readyState !== WebSocket.OPEN)) {
        connectWebSocket();
      } else if (currentNumber && !document.hidden) {
        updateGameDisplay();
      }
    });
  </script>
</body>
</html>

