<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0" />
    <title>Favipong</title>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: #000;
        overflow: hidden;
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #gameCanvas {
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        width: 100vw;
        height: 100vh;
        object-fit: fill;
      }
    </style>
  </head>
  <body>
    <canvas
      id="gameCanvas"
      width="16"
      height="16"></canvas>

    <script>
      // ========== CONFIGURATION ==========
      // Server URLs
      const WS_URL_LOCAL = "ws://localhost:8080";
      const WS_URL_PRODUCTION = "wss://favipong.onrender.com";

      // Get server mode from localStorage (default: local for hackathon)
      function getServerMode() {
        const saved = localStorage.getItem("serverMode");
        return saved || "local"; // Default to local for hackathon
      }

      function setServerMode(mode) {
        localStorage.setItem("serverMode", mode);
      }

      // Get WebSocket URL based on mode
      function getWebSocketURL() {
        const mode = getServerMode();
        return mode === "local" ? WS_URL_LOCAL : WS_URL_PRODUCTION;
      }

      let WS_URL = getWebSocketURL();
      const MAX_RECONNECT_ATTEMPTS = 5;
      const RECONNECT_DELAY_BASE = 2000; // ms
      const PADDLE_MOVE_INTERVAL = 50; // ms (slower paddle movement)

      // Canvas settings
      const CANVAS_WIDTH = 16;
      const CANVAS_HEIGHT = 16;
      const CENTER_X = CANVAS_WIDTH / 2;
      const CENTER_Y = CANVAS_HEIGHT / 2;

      // Visual settings
      const BALL_COLOR = "#FFFFFF";
      const BACKGROUND_COLOR = "#000000";
      const TEAM_RED_COLOR = "#FF4444";
      const TEAM_BLUE_COLOR = "#4444FF";
      const WARNING_LINE_COLOR = "rgba(255, 255, 255, ";
      const SCORE_FLASH_GREEN = "#00FF00";
      const SCORE_FLASH_RED = "#FF0000";
      const SCORE_FLASH_DURATION = 30; // frames

      // Paddle settings
      const PADDLE_SIZE = 2;
      const PADDLE_WIDTH = 1; // For vertical paddles
      const PADDLE_HEIGHT = 1; // For horizontal paddles
      const PADDLE_COLLISION_TOLERANCE = 2;

      // Warning line settings
      const WARNING_DISTANCE_MULTIPLIER = 2; // Show warning within 2 favicons
      // ===================================

      // Sound initialization
      let pongSynth = null;
      let soundInitialized = false;

      async function initSound() {
        if (soundInitialized) return;
        try {
          await Tone.start();
          // Create a pong sound: short beep with a quick attack and decay
          pongSynth = new Tone.Synth({
            oscillator: {
              type: "square",
            },
            envelope: {
              attack: 0.01,
              decay: 0.1,
              sustain: 0,
              release: 0.1,
            },
          }).toDestination();
          soundInitialized = true;
        } catch (error) {
          console.warn("Could not initialize sound:", error);
        }
      }

      function playPongSound() {
        if (!soundInitialized || !pongSynth) return;
        try {
          // Play a pong sound at 440Hz (A4) for 0.1 seconds
          pongSynth.triggerAttackRelease("A4", "8n");
        } catch (error) {
          console.warn("Could not play sound:", error);
        }
      }

      // Initialize sound on user interaction
      document.addEventListener("click", initSound, { once: true });
      document.addEventListener("keydown", initSound, { once: true });

      // Game state
      let currentNumber = null;
      let totalPlayers = 0;
      let currentTeam = null;
      let ws = null;
      let reconnectAttempts = 0;

      // Game state from server
      let gameState = {
        ballX: CENTER_X,
        ballY: CENTER_Y,
        ballVelX: 0.15,
        paddlePositions: {},
        teamScores: { red: 0, blue: 0 },
        lastScoringTeam: null,
      };

      // Score flash state
      let scoreFlashFrames = 0;
      let flashColor = null; // 'green' or 'red'
      let previousBallX = null;
      let previousBallY = null;
      let previousBallVelX = null;
      let previousBallVelY = null;
      let ballWasInMyArea = false;

      // Paddle movement keys
      const keys = {};

      // Canvas elements
      const faviconCanvas = document.createElement("canvas");
      faviconCanvas.width = CANVAS_WIDTH;
      faviconCanvas.height = CANVAS_HEIGHT;
      const faviconCtx = faviconCanvas.getContext("2d");
      faviconCtx.imageSmoothingEnabled = false; // Ensure pixelated rendering

      const gameCanvas = document.getElementById("gameCanvas");
      const gameCtx = gameCanvas.getContext("2d");
      gameCtx.imageSmoothingEnabled = false; // Ensure pixelated rendering

      // Ensure both canvases have the same dimensions
      if (gameCanvas.width !== CANVAS_WIDTH || gameCanvas.height !== CANVAS_HEIGHT) {
        gameCanvas.width = CANVAS_WIDTH;
        gameCanvas.height = CANVAS_HEIGHT;
      }

      // Get team color for current player (always use persistent team)
      function getTeamColor() {
        // Always use currentTeam - should be set by server
        if (currentTeam === "red") {
          return TEAM_RED_COLOR;
        } else if (currentTeam === "blue") {
          return TEAM_BLUE_COLOR;
        }
        // Fallback only if team not set yet
        return TEAM_RED_COLOR;
      }

      // Track previous scores to only update title when score changes
      let previousRedScore = null;
      let previousBlueScore = null;

      // Update document title with scores (only when score changes)
      function updateTitle() {
        if (!gameState.teamScores) return;
        const redScore = gameState.teamScores.red || 0;
        const blueScore = gameState.teamScores.blue || 0;

        // Only update if score changed
        if (redScore !== previousRedScore || blueScore !== previousBlueScore) {
          document.title = `${redScore}:${blueScore}`;
          previousRedScore = redScore;
          previousBlueScore = blueScore;
        }
      }

      // Check if ball is in player's area
      function isBallInMyArea() {
        if (!currentNumber || !totalPlayers) return false;
        const faviconStartX = (currentNumber - 1) * CANVAS_WIDTH;
        const faviconEndX = currentNumber * CANVAS_WIDTH;
        return gameState.ballX >= faviconStartX && gameState.ballX < faviconEndX;
      }

      // Check if ball is near player's paddle edge
      function isBallNearPaddleEdge() {
        if (!currentNumber || !totalPlayers) return false;

        const faviconStartX = (currentNumber - 1) * CANVAS_WIDTH;
        const faviconEndX = currentNumber * CANVAS_WIDTH;
        const paddleY = gameState.paddlePositions[currentNumber] || CENTER_Y;

        // Player 1: left edge paddle
        if (currentNumber === 1) {
          const ballAtLeftEdge = gameState.ballX <= PADDLE_SIZE + 1;
          const ballNearPaddleY = Math.abs(gameState.ballY - paddleY) <= PADDLE_SIZE + PADDLE_COLLISION_TOLERANCE;
          return ballAtLeftEdge && ballNearPaddleY;
        }
        // Last player: right edge paddle
        else if (currentNumber === totalPlayers) {
          const ballAtRightEdge = gameState.ballX >= faviconEndX - PADDLE_SIZE - 1;
          const ballNearPaddleY = Math.abs(gameState.ballY - paddleY) <= PADDLE_SIZE + PADDLE_COLLISION_TOLERANCE;
          return ballAtRightEdge && ballNearPaddleY;
        }
        // Middle players: top/bottom paddles
        else {
          const paddleX = (currentNumber - 1) * CANVAS_WIDTH + paddleY;
          const ballAtTop = gameState.ballY <= PADDLE_SIZE + 1;
          const ballAtBottom = gameState.ballY >= CANVAS_HEIGHT - PADDLE_SIZE - 1;
          const ballNearPaddleX = Math.abs(gameState.ballX - paddleX) <= PADDLE_SIZE + PADDLE_COLLISION_TOLERANCE;
          return (ballAtTop || ballAtBottom) && ballNearPaddleX;
        }
      }

      // Check for hit/miss and trigger flash
      function checkHitOrMiss() {
        if (!currentNumber || !totalPlayers) {
          ballWasInMyArea = false;
          previousBallX = gameState.ballX;
          previousBallY = gameState.ballY;
          previousBallVelX = gameState.ballVelX;
          previousBallVelY = gameState.ballVelY;
          return;
        }

        const ballInMyArea = isBallInMyArea();
        const faviconStartX = (currentNumber - 1) * CANVAS_WIDTH;
        const faviconEndX = currentNumber * CANVAS_WIDTH;
        const worldWidth = CANVAS_WIDTH * totalPlayers;

        // Ball just entered my area
        if (ballInMyArea && !ballWasInMyArea) {
          ballWasInMyArea = true;
        }

        // Check for velocity change (indicates a collision)
        const velocityChangedX =
          previousBallVelX !== null &&
          ((previousBallVelX > 0 && gameState.ballVelX < 0) || (previousBallVelX < 0 && gameState.ballVelX > 0));
        const velocityChangedY =
          previousBallVelY !== null &&
          ((previousBallVelY > 0 && gameState.ballVelY < 0) || (previousBallVelY < 0 && gameState.ballVelY > 0));

        const isEdgePlayer = currentNumber === 1 || currentNumber === totalPlayers;

        // For edge players (left/right paddles)
        if (isEdgePlayer && velocityChangedX) {
          // Player 1: Check if ball hit left wall (missed paddle)
          if (currentNumber === 1) {
            // Wall hit: ball is exactly at 0 (server sets ballX = 0 when hitting wall)
            // Paddle hit: ball is at 1 (server sets ballX = 1 when hitting paddle)
            // Check if ball is at the wall position (x <= 0.5) and velocity changed from left to right
            const hitLeftWall = gameState.ballX <= 0.5 && previousBallVelX !== null && previousBallVelX < 0 && gameState.ballVelX > 0;
            const ballNearPaddle = isBallNearPaddleEdge();

            // Priority: wall hit detection first (if ball is at x=0, it hit the wall)
            // Paddle hits set ballX = 1, so we check for x <= 0.5 to catch wall hits
            if (hitLeftWall) {
              // Ball hit the wall - red flash (missed paddle)
              scoreFlashFrames = SCORE_FLASH_DURATION;
              flashColor = "red";
            } else if (ballNearPaddle) {
              // Ball hit the paddle - green flash (hit paddle)
              // This happens when ball bounces off paddle (ballX = 1)
              scoreFlashFrames = SCORE_FLASH_DURATION;
              flashColor = "green";
              playPongSound();
            }
          }
          // Last player: Check if ball hit right wall (missed paddle)
          else if (currentNumber === totalPlayers) {
            // Wall hit: ball is at or very close to worldWidth
            // Check if ball is at the wall position and velocity changed from right to left
            const hitRightWall =
              gameState.ballX >= worldWidth - 1 && previousBallVelX !== null && previousBallVelX > 0 && gameState.ballVelX < 0;
            const ballNearPaddle = isBallNearPaddleEdge();

            // Priority: wall hit detection first (if ball is at worldWidth-1 or worldWidth, it hit the wall)
            if (hitRightWall) {
              // Ball hit the wall - red flash (missed paddle)
              scoreFlashFrames = SCORE_FLASH_DURATION;
              flashColor = "red";
            } else if (ballNearPaddle && gameState.ballX < worldWidth - 1) {
              // Ball hit the paddle - green flash (hit paddle)
              // Only if ball is NOT at the wall position
              scoreFlashFrames = SCORE_FLASH_DURATION;
              flashColor = "green";
              playPongSound();
            }
          }
        }
        // For middle players (top/bottom paddles)
        else if (!isEdgePlayer && velocityChangedY) {
          const ballNearPaddle = isBallNearPaddleEdge();
          if (ballNearPaddle) {
            // Ball hit the paddle - green flash
            scoreFlashFrames = SCORE_FLASH_DURATION;
            flashColor = "green";
            playPongSound();
          }
        }

        previousBallX = gameState.ballX;
        previousBallY = gameState.ballY;
        previousBallVelX = gameState.ballVelX;
        previousBallVelY = gameState.ballVelY;

        if (scoreFlashFrames > 0) {
          scoreFlashFrames--;
        } else {
          flashColor = null;
        }
      }

      // Render game to canvas
      function renderGame(canvas, ctx) {
        if (!currentNumber || !totalPlayers) {
          ctx.fillStyle = BACKGROUND_COLOR;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          return;
        }

        // Enable pixelated rendering
        ctx.imageSmoothingEnabled = false;

        // Draw background with flash effect
        if (scoreFlashFrames > 0 && flashColor) {
          const flashColorHex = flashColor === "green" ? SCORE_FLASH_GREEN : SCORE_FLASH_RED;
          const flashIntensity = scoreFlashFrames / SCORE_FLASH_DURATION;
          ctx.fillStyle = flashColorHex;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = BACKGROUND_COLOR;
          ctx.globalAlpha = 1 - flashIntensity * 0.5;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.globalAlpha = 1;
        } else {
          ctx.fillStyle = BACKGROUND_COLOR;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Calculate this favicon's slice of the world
        const faviconStartX = (currentNumber - 1) * CANVAS_WIDTH;
        const faviconEndX = currentNumber * CANVAS_WIDTH;
        const worldWidth = CANVAS_WIDTH * totalPlayers;
        // Scale warning distance with number of players (more players = longer warning range)
        const maxWarningDistance = CANVAS_WIDTH * WARNING_DISTANCE_MULTIPLIER * totalPlayers;
        const ballInMyArea = gameState.ballX >= faviconStartX && gameState.ballX < faviconEndX;

        // Warning indicator: small paddle (same size as ball) showing where ball will come from
        // Left indicator (ball coming from left)
        // Player 1 (leftmost) should NOT see left indicator - ball can't come from left
        if (currentNumber !== 1) {
          const leftEdgeX = faviconStartX;
          const distanceFromLeftEdge = gameState.ballX - leftEdgeX;
          if (distanceFromLeftEdge >= -maxWarningDistance && distanceFromLeftEdge <= maxWarningDistance && gameState.ballVelX > 0) {
            // Show indicator at predicted Y position where ball will hit
            // Use ball's current Y position as prediction
            const indicatorY = Math.floor(gameState.ballY);
            const distance = Math.abs(distanceFromLeftEdge);
            // Closer = more opaque (1.0 when very close, 0.0 when far)
            const intensity = Math.max(0, 1 - distance / maxWarningDistance);
            const opacity = intensity; // Range from 0.0 to 1.0

            if (intensity > 0 && indicatorY >= 0 && indicatorY < CANVAS_HEIGHT) {
              ctx.fillStyle = "#FFFFFF"; // White
              ctx.globalAlpha = opacity;
              ctx.fillRect(0, indicatorY, 1, 1); // Same size as ball (1x1)
              ctx.globalAlpha = 1;
            }
          }
        }

        // Right indicator (ball coming from right)
        // Last player (rightmost) should NOT see right indicator - ball can't come from right
        if (currentNumber !== totalPlayers) {
          const rightEdgeX = faviconEndX;
          const distanceFromRightEdge = rightEdgeX - gameState.ballX;
          if (distanceFromRightEdge >= -maxWarningDistance && distanceFromRightEdge <= maxWarningDistance && gameState.ballVelX < 0) {
            // Show indicator at predicted Y position where ball will hit
            const indicatorY = Math.floor(gameState.ballY);
            const distance = Math.abs(distanceFromRightEdge);
            // Closer = more opaque (1.0 when very close, 0.0 when far)
            const intensity = Math.max(0, 1 - distance / maxWarningDistance);
            const opacity = intensity; // Range from 0.0 to 1.0

            if (intensity > 0 && indicatorY >= 0 && indicatorY < CANVAS_HEIGHT) {
              ctx.fillStyle = "#FFFFFF"; // White
              ctx.globalAlpha = opacity;
              ctx.fillRect(CANVAS_WIDTH - 1, indicatorY, 1, 1); // Same size as ball (1x1)
              ctx.globalAlpha = 1;
            }
          }
        }

        // Draw ball only if it's in this favicon's slice
        if (gameState.ballX >= faviconStartX && gameState.ballX < faviconEndX) {
          const localBallX = gameState.ballX - faviconStartX;
          ctx.fillStyle = BALL_COLOR;
          ctx.fillRect(Math.floor(localBallX), Math.floor(gameState.ballY), 1, 1);
        }

        // Draw ONLY the current player's paddle with their team color
        if (currentNumber === 1) {
          // Player 1: Left paddle (vertical) at left edge
          const paddleY = gameState.paddlePositions[currentNumber] || CENTER_Y;
          ctx.fillStyle = getTeamColor();
          ctx.fillRect(0, paddleY - PADDLE_SIZE, PADDLE_WIDTH, PADDLE_SIZE * 2);
        } else if (currentNumber === totalPlayers && totalPlayers > 1) {
          // Last player: Right paddle (vertical) at right edge
          const paddleY = gameState.paddlePositions[currentNumber] || CENTER_Y;
          ctx.fillStyle = getTeamColor();
          ctx.fillRect(CANVAS_WIDTH - 1, paddleY - PADDLE_SIZE, PADDLE_WIDTH, PADDLE_SIZE * 2);
        } else if (currentNumber > 1 && currentNumber < totalPlayers) {
          // Middle players: Top and bottom paddles (horizontal)
          const paddleX = gameState.paddlePositions[currentNumber] || CENTER_Y;
          const teamColor = getTeamColor();

          // Top paddle
          ctx.fillStyle = teamColor;
          ctx.fillRect(paddleX - PADDLE_SIZE, 0, PADDLE_SIZE * 2, PADDLE_HEIGHT);

          // Bottom paddle
          ctx.fillStyle = teamColor;
          ctx.fillRect(paddleX - PADDLE_SIZE, CANVAS_HEIGHT - 1, PADDLE_SIZE * 2, PADDLE_HEIGHT);
        }
      }

      function updateFavicon() {
        // Use the same renderGame function to ensure identical rendering
        renderGame(faviconCanvas, faviconCtx);
        const dataUrl = faviconCanvas.toDataURL("image/png");

        let faviconLink = document.querySelector("link[rel*='icon']");
        if (!faviconLink) {
          faviconLink = document.createElement("link");
          faviconLink.rel = "icon";
          document.head.appendChild(faviconLink);
        }
        faviconLink.href = dataUrl;

        let appleIcon = document.querySelector("link[rel='apple-touch-icon']");
        if (appleIcon) {
          appleIcon.href = dataUrl;
        }
      }

      function updateGameDisplay() {
        // Check for hit/miss once per frame (before rendering both canvases)
        if (currentNumber && totalPlayers) {
          checkHitOrMiss();
        }

        // Render both canvases using the same function to ensure they're identical
        renderGame(gameCanvas, gameCtx);
        renderGame(faviconCanvas, faviconCtx);

        // Update favicon link after rendering
        const dataUrl = faviconCanvas.toDataURL("image/png");
        let faviconLink = document.querySelector("link[rel*='icon']");
        if (!faviconLink) {
          faviconLink = document.createElement("link");
          faviconLink.rel = "icon";
          document.head.appendChild(faviconLink);
        }
        faviconLink.href = dataUrl;

        let appleIcon = document.querySelector("link[rel='apple-touch-icon']");
        if (appleIcon) {
          appleIcon.href = dataUrl;
        }

        updateTitle();
      }

      function connectWebSocket() {
        // Prevent multiple connection attempts
        if (ws) {
          if (ws.readyState === WebSocket.OPEN) {
            return; // Already connected
          }
          if (ws.readyState === WebSocket.CONNECTING) {
            return; // Already connecting
          }
          // Close any existing connection that's not open or connecting
          ws.close();
        }

        // Update URL in case mode changed
        WS_URL = getWebSocketURL();

        try {
          const mode = getServerMode();
          console.log(`Connecting to ${mode} WebSocket server: ${WS_URL}...`);
          ws = new WebSocket(WS_URL);

          ws.onopen = () => {
            console.log("Connected to WebSocket server");
            reconnectAttempts = 0;
          };

          ws.onmessage = (event) => {
            try {
              const message = JSON.parse(event.data);

              if (message.type === "assigned") {
                currentNumber = message.number;
                totalPlayers = message.totalPlayers || 0;
                currentTeam = message.team || null;
                console.log("Assigned number:", currentNumber, "Team:", currentTeam, "Total players:", totalPlayers);
                setupControls();
                updateGameDisplay();
              } else if (message.type === "gameState") {
                gameState.ballX = message.ballX || CENTER_X;
                gameState.ballY = message.ballY || CENTER_Y;
                gameState.ballVelX = message.ballVelX || 0.15;
                gameState.paddlePositions = message.paddlePositions || {};
                gameState.teamScores = message.teamScores || { red: 0, blue: 0 };
                gameState.lastScoringTeam = message.lastScoringTeam || null;
                totalPlayers = message.totalPlayers || totalPlayers;
                updateGameDisplay();
              }
            } catch (error) {
              console.error("Error parsing WebSocket message:", error);
            }
          };

          ws.onerror = (error) => {
            console.error("WebSocket error:", error);
          };

          ws.onclose = () => {
            console.log("WebSocket connection closed");
            ws = null;
            currentNumber = null;

            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
              reconnectAttempts++;
              setTimeout(() => {
                console.log(`Reconnecting... (attempt ${reconnectAttempts})`);
                connectWebSocket();
              }, RECONNECT_DELAY_BASE * reconnectAttempts);
            }
          };
        } catch (error) {
          console.error("Error creating WebSocket connection:", error);
          if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
            reconnectAttempts++;
            setTimeout(() => {
              console.log(`Retrying connection... (attempt ${reconnectAttempts})`);
              connectWebSocket();
            }, RECONNECT_DELAY_BASE * reconnectAttempts);
          }
        }
      }

      let paddleMoveInterval = null;

      function setupControls() {
        if (!currentNumber || !ws) return;

        document.removeEventListener("keydown", handlePaddleKeyDown);
        document.removeEventListener("keyup", handlePaddleKeyUp);

        document.addEventListener("keydown", handlePaddleKeyDown);
        document.addEventListener("keyup", handlePaddleKeyUp);
      }

      function handlePaddleKeyDown(e) {
        if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
          return;
        }

        // Player 1 or last player: Up/Down for vertical paddles
        if ((currentNumber === 1 || currentNumber === totalPlayers) && totalPlayers > 1) {
          if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") {
            e.preventDefault();
            if (!keys.up) {
              keys.up = true;
              sendPaddleMove("up");
              startContinuousMove("up");
            }
          } else if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") {
            e.preventDefault();
            if (!keys.down) {
              keys.down = true;
              sendPaddleMove("down");
              startContinuousMove("down");
            }
          }
        }
        // Middle players: Left/Right for horizontal paddles
        else if (currentNumber > 1 && currentNumber < totalPlayers) {
          if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") {
            e.preventDefault();
            if (!keys.left) {
              keys.left = true;
              sendPaddleMove("left");
              startContinuousMove("left");
            }
          } else if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") {
            e.preventDefault();
            if (!keys.right) {
              keys.right = true;
              sendPaddleMove("right");
              startContinuousMove("right");
            }
          }
        }
      }

      function startContinuousMove(direction) {
        if (paddleMoveInterval) {
          clearInterval(paddleMoveInterval);
        }
        paddleMoveInterval = setInterval(() => {
          if (
            (direction === "up" && keys.up) ||
            (direction === "down" && keys.down) ||
            (direction === "left" && keys.left) ||
            (direction === "right" && keys.right)
          ) {
            sendPaddleMove(direction);
          } else {
            clearInterval(paddleMoveInterval);
            paddleMoveInterval = null;
          }
        }, PADDLE_MOVE_INTERVAL);
      }

      function handlePaddleKeyUp(e) {
        if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") {
          keys.up = false;
          if (paddleMoveInterval && !keys.down && !keys.left && !keys.right) {
            clearInterval(paddleMoveInterval);
            paddleMoveInterval = null;
          }
        } else if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") {
          keys.down = false;
          if (paddleMoveInterval && !keys.up && !keys.left && !keys.right) {
            clearInterval(paddleMoveInterval);
            paddleMoveInterval = null;
          }
        } else if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") {
          keys.left = false;
          if (paddleMoveInterval && !keys.up && !keys.down && !keys.right) {
            clearInterval(paddleMoveInterval);
            paddleMoveInterval = null;
          }
        } else if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") {
          keys.right = false;
          if (paddleMoveInterval && !keys.up && !keys.down && !keys.left) {
            clearInterval(paddleMoveInterval);
            paddleMoveInterval = null;
          }
        }
      }

      function sendPaddleMove(direction) {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(
            JSON.stringify({
              type: "paddleMove",
              direction: direction,
            })
          );
        }
      }

      // Connect when page loads (only once)
      let connectionInitiated = false;
      function initConnection() {
        if (!connectionInitiated) {
          connectionInitiated = true;
          connectWebSocket();
        }
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initConnection);
      } else {
        initConnection();
      }

      // Reconnect on page visibility change
      document.addEventListener("visibilitychange", () => {
        if (!document.hidden && (!ws || ws.readyState !== WebSocket.OPEN)) {
          connectWebSocket();
        } else if (currentNumber && !document.hidden) {
          updateGameDisplay();
        }
      });
    </script>
  </body>
</html>
